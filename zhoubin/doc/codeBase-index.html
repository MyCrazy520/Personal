<!DOCTYPE html>
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->
<head>
	<meta charset="utf-8">
	<title>ZHOU BIN</title>
	<meta name="description" content="">
	<!-- Mobile Specific Meta -->
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<!-- <link rel="shortcut icon" href="img/favicon.png"> -->
	<link href='http://fonts.googleapis.com/css?family=Lato:300,400,700' rel='stylesheet'>

	<!-- Syntax Highlighter -->
	<link rel="stylesheet" type="text/css" href="syntax-highlighter/styles/shCore.css" media="all">
	<link rel="stylesheet" type="text/css" href="syntax-highlighter/styles/shThemeDefault.css" media="all">
	<!-- Font Awesome CSS-->
	<link rel="stylesheet" href="css/font-awesome.min.css">
	<!-- Normalize/Reset CSS-->
	<link rel="stylesheet" href="css/normalize.min.css">
	<!-- Main CSS-->
	<link rel="stylesheet" href="css/main.css">
	
</head>

<body id="welcome">
	
	<aside class="left-sidebar">
		<div class="logo">
			<a href="../index.html">
				<img src="img/logo.png" alt="">
			</a>
		</div>
		<nav class="left-nav">
			<ul id="nav">
				<li class="current"><a href="#java">JAVA</a></li>
				<li><a href="#python3">PYTHON3</a></li>
				<li><a href="#htmlCSS">HTML+CSS</a></li>
				<li><a href="#less">LESS</a></li>
				<li><a href="#javaScript">JAVASCRIPT</a></li>
				<li><a href="#jquery">Jquery</a></li>
				<li><a href="#shell">SHELL</a></li>
				<li><a href="#goLang">GOLANG</a></li>
				
			</ul>
		</nav>
	</aside>
	
	<div id="main-wrapper">
		<div class="main-content">

			<section id="java">
				<div class="content-header">
					<h1>JAVA常用特性</h1>
				</div>

				<div class="welcome">

					<h2 class="twenty">Java8排序和Java7排序</h2>
					<pre class="brush: java">
						private void sortUsingJava8(List&ltString&gt names){
							Collections.sort(names, (s1, s2) -> s1.compareTo(s2));
						}
					</pre>
					<pre class="brush: java">
						private void sortUsingJava7(List&ltString&gt names){
						  Collections.sort(names, new Comparator&ltString&gt() {
							 @Override
							 public int compare(String s1, String s2) {
								return s1.compareTo(s2);
							 }
						  });
					    }
					</pre>
				</div>

				<div class="features">
					<h2 class="twenty">Java 8 日期时间 API</h2>
					<pre class="brush: java">
						// 本地化日期时间 API
						public void testLocalDateTime(){

						  LocalDateTime currentTime = LocalDateTime.now();
						  System.out.println("当前时间: " + currentTime);

						  LocalDate date1 = currentTime.toLocalDate();
						  System.out.println("date1: " + date1);

						  Month month = currentTime.getMonth();
						  int day = currentTime.getDayOfMonth();
						  int seconds = currentTime.getSecond();

						  System.out.println("月: " + month +", 日: " + day +", 秒: " + seconds);

						  LocalDateTime date2 = currentTime.withDayOfMonth(10).withYear(2012);
						  System.out.println("date2: " + date2);

						  // 12 december 2014
						  LocalDate date3 = LocalDate.of(2014, Month.DECEMBER, 12);
						  System.out.println("date3: " + date3);

						  // 22 小时 15 分钟
						  LocalTime date4 = LocalTime.of(22, 15);
						  System.out.println("date4: " + date4);

						  // 解析字符串
						  LocalTime date5 = LocalTime.parse("20:15:30");
						  System.out.println("date5: " + date5);
					   	}


						//输出结果如下:
						当前时间: 2016-09-15T20:55:48.668
						date1: 2016-04-15
						月: APRIL, 日: 15, 秒: 48
						date2: 2016-09-15T20:55:48.668
						date3: 2014-12-12
						date4: 22:15
						date5: 20:15:30


						// 使用时区的日期时间API
						public void testZonedDateTime(){

							ZonedDateTime date1 = ZonedDateTime.parse("2015-12-03T10:15:30+05:30[Asia/Shanghai]");
							System.out.println("date1: " + date1);

							ZoneId id = ZoneId.of("Europe/Paris");
							System.out.println("ZoneId: " + id);

							ZoneId currentZone = ZoneId.systemDefault();
							System.out.println("当期时区: " + currentZone);
						}


						//输出结果如下:
						date1: 2015-12-03T10:15:30+08:00[Asia/Shanghai]
						ZoneId: Europe/Paris
						当期时区: Asia/Shanghai

					</pre>

				</div>

				<div class="features">
					<h2 class="twenty">并行数组</h2>
					<pre class="brush: java">
						// 本地化日期时间 API
						public void testParallelSort(){

						  long[] arrayOfLong = new long [ 20000 ];

							Arrays.parallelSetAll( arrayOfLong,
								index -> ThreadLocalRandom.current().nextInt( 1000000 ) );
							Arrays.stream( arrayOfLong ).limit( 10 ).forEach(
								i -> System.out.print( i + " " ) );
							System.out.println();

							Arrays.parallelSort( arrayOfLong );
							Arrays.stream( arrayOfLong ).limit( 10 ).forEach(
								i -> System.out.print( i + " " ) );
							System.out.println();
						}

						//输出结果如下:
						Unsorted: 591217 891976 443951 424479 766825 351964 242997 642839 119108 552378
						Sorted: 39 220 263 268 325 607 655 678 723 793
					</pre>

				</div>

				<div class="section-content">
					<h2 class="twenty">Java 8 JVM的新特性</h2>
					<ol>
						使用Metaspace（JEP 122）代替持久代（PermGen space）。在JVM参数方面，使用-XX:MetaSpaceSize和-XX:MaxMetaspaceSize代替原来的-XX:PermSize和-XX:MaxPermSize
					</ol>

				</div>

				<div class="section-content">
					<h2 class="twenty">HashMap和CurrentHashMap</h2>
					<ol>
						<li>HashMap没有锁机制，不是线程安全的;而CurrentHashMap在每个分段片上都用锁进行保护，从而让锁的粒度更精细一些，并发性能更好</li>
						<li>ConcurrentHashMap对整个桶数组进行了分段，而HashMap则没有</li>
						<li>Synchronized Map和Hashtable效率低</li>
					</ol>

				</div>

				<div class="section-content">
					<h2 class="twenty">BlockingQuee中ArrayBlockingQueue,LinkedBlockingQueue</h2>
					<ol>
						<li>基于数组的阻塞队列实现，在ArrayBlockingQueue内部，维护了一个定长数组，以便缓存队列中的数据对象，这是一个常用的阻塞队列，除了一个定长数组外，ArrayBlockingQueue内部还保存着两个整形变量，分别标识着队列的头部和尾部在数组中的位置</li>
						<li>基于链表的阻塞队列，同ArrayListBlockingQueue类似，其内部也维持着一个数据缓冲队列（该队列由一个链表构成），当生产者往队列中放入一个数据时，队列会从生产者手中获取数据，并缓存在队列内部，而生产者立即返回；只有当队列缓冲区达到最大值缓存容量时（LinkedBlockingQueue可以通过构造函数指定该值），才会阻塞生产者队列，直到消费者从队列中消费掉一份数据，生产者线程会被唤醒，反之对于消费者这端的处理也基于同样的原理</li>
						<li>如果构造一个LinkedBlockingQueue对象，而没有指定其容量大小，LinkedBlockingQueue会默认一个类似无限大小的容量（Integer.MAX_VALUE），这样的话，如果生产者的速度一旦大于消费者的速度，也许还没有等到队列满阻塞产生，系统内存就有可能已被消耗殆尽了</li>
					</ol>
				</div>

				<div class="section-content">
					<h2 class="twenty">ConcurrentLinkedQueue一个很好用的队列</h2>
					<ol>
						<li>offer是往队列添加元素，poll是从队列取出元素并且删除该元素</li>
						<li>peek:获取但不移除此队列的头；如果此队列为空，则返回 null</li>
						<li>contains:如果此队列包含指定元素，则返回 true</li>
						<li>iterator:返回在此队列元素上以恰当顺序进行迭代的迭代器</li>
						<pre class="brush:java">
							public static void main(String[] args) throws InterruptedException {
								ConcurrentLinkedQueue$lt;String$rt; queue = new ConcurrentLinkedQueue$lt;String$rt;();
								queue.offer("123");
								queue.offer("234");
								Iterator$lt;String$rt; iterator = queue.iterator();
								while (iterator.hasNext()){
									System.out.println(iterator.next());
								}
							}
						</pre>

					</ol>
				</div>

				<div class="section-content">
					<h2 class="twenty">Java中的BIO,NIO,AIO</h2>
					<ol>
						<li>BIO:JDK1.4以前用的是BIO,阻塞IO</li>
						<li>NIO:同步非阻塞方式，目前的主流，采用多路复用技术:</li>
						<pre class="brush: java">
							public class NioServer implements Runnable{

								private Selector selector;
								private ByteBuffer readBuf = ByteBuffer.allocate(1024);
								private ByteBuffer writeBuf = ByteBuffer.allocate(1024);

								public NioServer(int port) throws IOException {

									this.selector = Selector.open();//创建多路复用
									ServerSocketChannel ssc = ServerSocketChannel.open();//创建通道
									ssc.configureBlocking(false);//设置通道是否阻塞，如果为true，就和BIO类似
									ssc.bind(new InetSocketAddress(port));//设置通道地址
									ssc.register(this.selector, SelectionKey.OP_ACCEPT);//将ServerSocket通道注册到selector上，指定监听accept事件
									System.out.println("BioServer start");
								}
								@Override
								public void run() {
									 while(true){
										 try {
											 this.selector.select();//select阻塞，监听相关事件

											 //解除阻塞，返回key,key中含有通道，状态等信息
											 Iterator&lt;SelectionKey&rt; keysIter = this.selector.selectedKeys().iterator();
											 //遍历
											 while(keysIter.hasNext()){
												 SelectionKey key = keysIter.next();
												 keysIter.remove();
												 if(key.isValid()){
													 if(key.isAcceptable()){
														 this.accept(key);
													 }
													 if(key.isReadable()){
														 this.read(key);
													 }
													 if(key.isWritable()){
														 this.write(key);
													 }

												 }
											 }

										 } catch (IOException e) {
											 e.printStackTrace();
										 }
									 }
								}

								private void accept(SelectionKey key) {
									try {
										// 获取服务通道
										ServerSocketChannel ssc =  (ServerSocketChannel) key.channel();
										// 获取客户端通道.
										SocketChannel sc = ssc.accept();
										// 设置非阻塞模式
										sc.configureBlocking(false);
										// 将客户端通道注册到多路复用器上，指定监听事件
										sc.register(this.selector, SelectionKey.OP_READ | SelectionKey.OP_WRITE);
									} catch (IOException e) {
										e.printStackTrace();
									}
								}

								private void read(SelectionKey key) {
									try {
										// 获取通道
										SocketChannel sc = (SocketChannel) key.channel();
										// 读取数据, 读到buffer. 按程序运行顺序, 这里sc是否设置为阻塞效果都一样
										int count = sc.read(this.readBuf);  // readBuf写时会改变position的值
										if (count == -1) {
											key.channel().close();
											key.cancel();  //取消该通道在selector的注册, 之后不会被select轮询到
											return;
										}
										// 有数据则进行读取. 读取前需要将position和limit进行复位
										readBuf.flip();
										// 根据缓冲区的数据长度创建相应大小的byte数组, 接收缓冲区的数据
										byte[] bytes = new byte[this.readBuf.remaining()];
										// 接收缓冲区数据
										readBuf.get(bytes);
										readBuf.clear();
										String body = new String(bytes).trim();
										System.out.println("Server获取的请求: " + body);
										// 如果保持OP_READ会导致重复读
										sc.register(this.selector, SelectionKey.OP_WRITE);
									} catch (IOException e) {
										e.printStackTrace();
									}
								}

								private void write(SelectionKey key) {
									try {
										// 获取通道
										SocketChannel sc = (SocketChannel) key.channel();
										// 写回给客户端数据
										writeBuf.put("来自服务器的响应".getBytes());
										writeBuf.flip();
										sc.write(writeBuf);
										writeBuf.clear();
										// 修改监听的状态位, 如果保持OP_WRITE会导致重复写
										key.interestOps(SelectionKey.OP_READ);
									} catch (IOException e) {
										e.printStackTrace();
									}
								}

								public static void main(String[] args) throws IOException {
									new Thread(new NioServer(8090)).start();;
								}

							}
						</pre>
						<pre class="brush: java">
							public class NioClient {
								public static void main(String[] args) throws IOException {
									SocketChannel sc = null;
									ByteBuffer wrirteBuf = ByteBuffer.allocate(1024);
									ByteBuffer readBuf = ByteBuffer.allocate(1024);
									sc = SocketChannel.open();
									sc.connect(new InetSocketAddress("127.0.0.1",8090));

									while(true){
										byte[] bytes1 = new byte[1024];//定义一个数组
										System.in.read(bytes1);
										wrirteBuf.put(bytes1);//把数组放到缓冲区
										wrirteBuf.flip();//对缓冲区进行复位
										sc.write(wrirteBuf);//写入数据
										wrirteBuf.clear();//清空缓冲区

										sc.read(readBuf);//接收服务端相应
										readBuf.flip();
										byte[] bytes2 = new byte[readBuf.remaining()];
										readBuf.get(bytes2);
										String content = new String(bytes2);
										System.out.println("client获取数据:"+content);
									}
								}

							}
						</pre>
						<li>AIO:JDK1.7才实现真正的异步AIO术</li>
						<pre class="brush: java">
							public class AioServer {
								public AioServer(int port) throws IOException {
									AsynchronousServerSocketChannel listener = AsynchronousServerSocketChannel.open().bind(new InetSocketAddress(port));
									listener.accept(null, new CompletionHandler&lt;AsynchronousSocketChannel, Void&rt;() {
										@Override
										public void completed(AsynchronousSocketChannel ch, Void vi) {
											listener.accept(null,this);//接受下一个连接
											handler(ch);
										}

										@Override
										public void failed(Throwable exc, Void attachment) {
											System.out.println("async io error");
										}
									});
								}

								//业务逻辑
								public void handler(AsynchronousSocketChannel ch){
									ByteBuffer byteBuffer = ByteBuffer.allocate(32);
									try {
										ch.read(byteBuffer).get();
									} catch (InterruptedException e) {
										e.printStackTrace();
									} catch (ExecutionException e) {
										e.printStackTrace();
									}
									byteBuffer.flip();
									System.out.println("service accept:"+byteBuffer.get());
								}

								public static void main(String[] args) throws InterruptedException, IOException {
									int port = 7080;
									AioServer server= new AioServer(port);
									System.out.println("watcher listner:"+port);
									Thread.sleep(60000);
								}
							}
						</pre>
						<pre class="brush: java">
							public class AioClient {
								private AsynchronousSocketChannel client = null;
								public AioClient(String host, int port) throws IOException, ExecutionException, InterruptedException {
									client = AsynchronousSocketChannel.open();
									Future<?> future = client.connect(new InetSocketAddress(host,port));
									System.out.println("get:"+future.get());
								}

								public void write(byte b){
									ByteBuffer byteBuffer = ByteBuffer.allocate(32);
									byteBuffer.put(b);
									byteBuffer.flip();
									client.write(byteBuffer);
								}

								public static void main(String[] args ) throws InterruptedException, ExecutionException, IOException {
									AioClient client = new AioClient("127.0.0.1",7080);
									client.write((byte)34);
								}
							}
						</pre>
						<li>FileChanne</li>
						<pre class="brush:java">
							public  void readFile(String path) throws IOException {
								ByteBuffer byteBuffer = ByteBuffer.allocate(1024);//定义缓冲区
								FileChannel inFC = new FileInputStream(path).getChannel();
								byteBuffer.clear();
								int len = inFC.read(byteBuffer);
								String content = new String(byteBuffer.array(),0,len);
								System.out.println(content);
								inFC.close();
							}
							public void writeFile(String pathFile,String Content) throws IOException {
								FileChannel outFC = new FileOutputStream(pathFile,true).getChannel();

								ByteBuffer byteBuffer = ByteBuffer.wrap(Content.getBytes());
								outFC.write(byteBuffer);
								outFC.close();
							}

							public void readAndWrite(String sourceFile,String targetFile) throws IOException {
								ByteBuffer byteBuffer = ByteBuffer.allocate(1024);
								FileChannel readChannel = new FileInputStream(sourceFile).getChannel();
								FileChannel writeChannel = new FileOutputStream(targetFile,true).getChannel();
								while(true){
									byteBuffer.clear();
									int len = readChannel.read(byteBuffer);
									if(len==-1){
										break;
									}
									byteBuffer.flip();//重置posit位置
									writeChannel.write(byteBuffer);
								}
								readChannel.close();
								writeChannel.close();
							}
						</pre>
					</ol>
				</div>

			</section>

			<section id="python3">
				<div class="content-header">
					<h1>PYTHON3</h1>
				</div>

				<div class="features">
					<h2 class="twenty">List（列表）</h2>
					<pre class="brush: python">
						#!/usr/bin/python3

						list = [ 'abcd', 786 , 2.23, 'runoob', 70.2 ]
						tinylist = [123, 'runoob']

						print (list)            # 输出完整列表
						print (list[0])         # 输出列表第一个元素
						print (list[1:3])       # 从第二个开始输出到第三个元素
						print (list[2:])        # 输出从第三个元素开始的所有元素
						print (tinylist * 2)    # 输出两次列表
						print (list + tinylist) # 连接列表

						#以上实例输出结果：
						['abcd', 786, 2.23, 'runoob', 70.2]
						abcd
						[786, 2.23]
						[2.23, 'runoob', 70.2]
						[123, 'runoob', 123, 'runoob']
						['abcd', 786, 2.23, 'runoob', 70.2, 123, 'runoob']
					</pre>
					<h6>与Python字符串不一样的是，列表中的元素是可以改变的:</h6>
					<pre class="brush: python">
						>>>a = [1, 2, 3, 4, 5, 6]
						>>> a[0] = 9
						>>> a[2:5] = [13, 14, 15]
						>>> a
						[9, 2, 13, 14, 15, 6]
						>>> a[2:5] = []   # 将对应的元素值设置为 []
						>>> a
						[9, 2, 6]
					</pre>
					<h6>List内置了有很多方法:</h6>
					<pre class="brush: python">
						append
						pop
						remove:删除指定值,无序
						del
					</pre>

				</div>

				<div class="features">
					<h2 class="twenty">Tuple（元组）</h2>
					<pre class="brush: python">
						#!/usr/bin/python3

						tuple = ( 'abcd', 786 , 2.23, 'runoob', 70.2  )
						tinytuple = (123, 'runoob')

						print (tuple)             # 输出完整元组
						print (tuple[0])          # 输出元组的第一个元素
						print (tuple[1:3])        # 输出从第二个元素开始到第三个元素
						print (tuple[2:])         # 输出从第三个元素开始的所有元素
						print (tinytuple * 2)     # 输出两次元组
						print (tuple + tinytuple) # 连接元组

						#以上实例输出结果：
						('abcd', 786, 2.23, 'runoob', 70.2)
						abcd
						(786, 2.23)
						(2.23, 'runoob', 70.2)
						(123, 'runoob', 123, 'runoob')
						('abcd', 786, 2.23, 'runoob', 70.2, 123, 'runoob')
					</pre>

				</div>

				<div class="section-content">
					<h2 class="title">Set（集合）:</h2>
					<pre class="brush: python">
						#!/usr/bin/python3

						student = {'Tom', 'Jim', 'Mary', 'Tom', 'Jack', 'Rose'}
						print(student)   # 输出集合，重复的元素被自动去掉

						# 成员测试
						if 'Rose' in student :
							print('Rose 在集合中')
						else :
							print('Rose 不在集合中')


						# set可以进行集合运算
						a = set('abracadabra')
						b = set('alacazam')

						print(a)

						print(a - b)     # a 和 b 的差集

						print(a | b)     # a 和 b 的并集

						print(a & b)     # a 和 b 的交集

						print(a ^ b)     # a 和 b 中不同时存在的元素

						#以上实例输出结果：
						{'Mary', 'Jim', 'Rose', 'Jack', 'Tom'}
						Rose 在集合中
						{'b', 'a', 'c', 'r', 'd'}
						{'b', 'd', 'r'}
						{'l', 'r', 'a', 'c', 'z', 'm', 'b', 'd'}
						{'a', 'c'}
						{'l', 'r', 'z', 'm', 'b', 'd'}
					</pre>
				</div>

				<div class="section-content">
					<h2 class="title">Dictionary（字典）:</h2>
					<pre class="brush: python">
						#!/usr/bin/python3

						dict = {}
						dict['one'] = "1 - 菜鸟教程"
						dict[2]     = "2 - 菜鸟工具"




						print (dict['one'])       # 输出键为 'one' 的值
						print (dict[2])           # 输出键为 2 的值
						print (tinydict)          # 输出完整的字典
						print (tinydict.keys())   # 输出所有键
						print (tinydict.values()) # 输出所有值



						#以上实例输出结果：
						1 - 菜鸟教程
						2 - 菜鸟工具
						{'name': 'runoob', 'code': 1, 'site': 'www.runoob.com'}
						dict_keys(['name', 'code', 'site'])
						dict_values(['runoob', 1, 'www.runoob.com'])
					</pre>
					<pre class="brush: python">
						#直接从键值对序列中构建字典
						>>>dict([('Runoob', 1), ('Google', 2), ('Taobao', 3)])
						{'Taobao': 3, 'Runoob': 1, 'Google': 2}

						>>> {x: x**2 for x in (2, 4, 6)}
						{2: 4, 4: 16, 6: 36}

						>>> dict(Runoob=1, Google=2, Taobao=3)
						{'Runoob': 1, 'Google': 2, 'Taobao': 3}
					</pre>
				</div>


			</section>

			<section id="htmlCSS">
				<div class="content-header">
					<h1>HTML+CSS</h1>
				</div>


				<div class="features">
					<h2 class="twenty">CSS样式名之间空格,无空格和大于号的区别</h2>
					<p>CSS 多类选择器:IE7 之前的版本中，不同平台的 Internet Explorer 都不能正确地处理多类选择器</p>
					<pre class="brush: xml">
						<!--.layout.float两者之间无空格-->
						.layout.float { color: red; }
						<div class="layout float">被选择的元素</div>
					</pre>
					<p>CSS 后代选择器</p>
					<pre class="brush: xml">
						<!--.layout .float中间用空格隔开，表示后代选择器，选择的是.layout内的.float (两个元素之间的层次间隔可以是无限的)-->
						.layout .float{
						  color: orange;
						}
						<div class="layout">
							<div class="float">被选择的元素</div>
						</div>
					</pre>
					<p>CSS 子元素选择器</p>
					<pre class="brush: xml">
						<!--.layout > .float中间是大于号，表示元素的子元素-->
						.layout > .float{
						  color: blue;
						}
						<div class="layout">
							<div class="float">被选择的元素</div>
							<div>
								<div class="float">没有被选择的元素</div>
							</div>
						</div>
					</pre>

				</div>


			</section>

			<section id="less">
				
				<div class="content-header">
					<h1>LESS</h1>
				</div>

				<div class="features">
					<h2 class="twenty">混合</h2>
					<p>LESS代码</p>
					<pre class="brush: css">
						.rounded-corners (@radius: 5px) {
						  border-radius: @radius;
						  -webkit-border-radius: @radius;
						  -moz-border-radius: @radius;
						}

						#header {
						  .rounded-corners;
						}
						#footer {
						  .rounded-corners(10px);
						}
					</pre>
					<p>生成的CSS</p>
					<pre class="brush: css">
						#header {
						  border-radius: 5px;
						  -webkit-border-radius: 5px;
						  -moz-border-radius: 5px;
						}
						#footer {
						  border-radius: 10px;
						  -webkit-border-radius: 10px;
						  -moz-border-radius: 10px;
						}
					</pre>
				
				</div>

				<div class="features">
					<h2 class="twenty">嵌套规则</h2>
					<p>LESS代码</p>
					<pre class="brush: css">
						#header {
						  color: black;

						  .navigation {
							font-size: 12px;
						  }
						  .logo {
							width: 300px;
							&:hover { text-decoration: none }
						  }
						}
					</pre>
					<p>生成的CSS</p>
					<pre class="brush: css">
						#header { color: black; }
						#header .navigation {
						  font-size: 12px;
						}
						#header .logo { 
						  width: 300px; 
						}
						#header .logo:hover {
						  text-decoration: none;
						}
					</pre>
				
				</div>
				
				<div class="features">
					<h2 class="twenty">函数 & 运算</h2>
					<p>LESS代码</p>
					<pre class="brush: css">
						@the-border: 1px;
						@base-color: #111;
						@red:        #842210;

						#header {
						  color: @base-color * 3;
						  border-left: @the-border;
						  border-right: @the-border * 2;
						}
						#footer { 
						  color: @base-color + #003300;
						  border-color: desaturate(@red, 10%);
						}
					</pre>
					<p>生成的CSS</p>
					<pre class="brush: css">
						#header {
						  color: #333;
						  border-left: 1px;
						  border-right: 2px;
						}
						#footer { 
						  color: #114411;
						  border-color: #7d2717;
						}
					</pre>
				
				</div>
												
				<div class="features">
					<h2 class="twenty">作用域</h2>
					<p>LESS代码</p>
					<pre class="brush: css">
						@var: red;
						#page {
						  @var: white;
						  #header {
							color: @var; // white
						  }
						}

						#footer {
						  color: @var; // red  
						}
					</pre>				
				</div>

			</section>

			<section id="javaScript">
				<div class="content-header">
					<h1>javascript和jquery</h1>
				</div>

				<div class="features">
					<h2 class="twenty">arguments数组使用</h2>
					<pre class="brush: javascript">
						function testArguments(){ //arguments能获取函数中传入的所有参数
							var sum = 0;
							for(var i=0;i &lt; arguments.length; i++){
								sum += arguments[i];
							}
							return sum;
						}
						console.log(testArguments(1,3,5,6,7));
					</pre>
					<h2 class="twenty">函数自调用的写法</h2>
					<pre class="brush: jscript">
						(function(){console.log("函数自调用测试");})();
					</pre>
					<h2 class="twenty">函数作为参数使用</h2>
					<pre class="brush: javascript">
						function f1(fn){
							fn();//表明函数作为参数使用
						}
						function fn(){
							console.log("zhoubin");
						}
						f1(fn);//调用方法
					</pre>
					<h2 class="twenty">变量的作用域</h2>
					<h6>变量在函数内部是局部变量，其他任何情况下都是全局变量</h6>
					<h6>全局变量是不能被delete,但隐式全局变量是能被删除的</h6>
					<pre class="brush: javascript">
						while(var i=0;i<10;i++){
							var sum +=i;
						}
						console(sum);//此时能获取到sum;
					</pre>
					<pre class="brush: javascript">
						function fsum(){
							while(var i=0;i<10;i++){
								var sum +=i;
							}
						}
						console(sum);//此时不能获取sum
					</pre>
					<h2>函数调用的时候，会把函数的声明提升到同级的作用域的上面</h2>
					<h6>函数的声明提升到当前作用域的最前面，只会提升声明不会提升调用</h6>
					<h6>变量的声明会提升到变量使用之前</h6>
					<pre class="brush: javascript">
						f1();
						var num = 20;
						function f1(){
							console.log(num);
							num = 10;
						}

						//结果:undefined;
					</pre>
					<pre class="brush: javascript">

						var num = 20;
						function f1(){
							console.log(num);
							num = 10;
						}
						f1();//调用
						//结果:20;
					</pre>

					<h2>变量的声明提升到当前作用域的最前面，只会提升声明，不会提升调用</h2>
					<pre class="brush: javascript">

						f1();//---不能调用
						var f1 = function (){
							console.log(num);
							var num = 10;
						}

						//结果:undefined
					</pre>

					<h2>自定义构造函数创建对象</h2>
					<pre class="brush: javascript">
 						function Person(){
							this.name = "zhoubin";
							this.age = "18";
							this.say = function(){
								console.log("my name is:"+this.name+",age:"+this.age);
							}
						}
						var person = new Person();
						console.log(person.name);//zhoubin
						console.log(person["age"]);//18
						person.say();//my name is:zhoubin,age:18
						console(person instanceof Person);//判断函数的对象类型instanceof
					</pre>

					<h2>字面量方式创建对象</h2>
					<pre class="brush: javascript">

						var person ={};//map
						var list = [];//list

					</pre>
					<h2>json对象的循环</h2>
					<pre class="brush: javascript">
						var json = {
							"name":"zhoubin",
							"age":"18",
							"sex":"man"
						};
						for(var key in json){
							console.log(key);
							console.log(json[key]);
						}
					</pre>
					<h2>值类型和引用类型</h2>
					<h6>简单类型都是值类型，值类型的变量传递的是值</h6>
					<h6>复杂类型是引用类型，引用类型传递的是地址</h6>

					<h2>数组常用的方法</h2>
					<pre class="brush: javascript">
						arraya.contact(arrayb);//拼接数组
						Array.from(array);//克隆数组
						arrayaevery(function(elem,index){});//检测函数,返回值为boolean
					</pre>

					<h2>基本包装类型</h2>
					<h6>如果是一个对象&&true,结果为true</h6>
					<h6>如果是一个true&&对象,结果为对象</h6>
					<pre class="brush: javascript">
						var flag = new Boolean(false);
						var result = true && flag;
						var result2 = flag && true;
						console.log(result);//Boolean
						console.log(result2);//true
					</pre>
				</div>
			</section>

			<section id="jquery">
				<div class="content-header">
					<h1>jquery一些好玩函数</h1>
				</div>

				<div class="features">
					<h2 class="twenty">动画函数</h2>
					<pre class="brush: javascript">
						$(function(){
							//animate():改变div的高度，移动div
							$("#animate").click(function(){
								$("#box").animate({left:"200px"}).animate({height:"100px"});
							});
						});
					</pre>
					<p>结果如下:<button type="button" id="animate" class="btn btn-primary btn-lg">点我移动</button><button type="button" id="animateColor" class="btn btn-primary btn-lg">点我变色</button></p>
					<div class="cover" style="height:100px;border:1px solid #D6D6D6;padding: 5px;">
						<div id="box" style="background:#98bf21;height:50px;width:50px;position:absolute;">
						</div>
					</div>
					<div class="cover" style="height:100px;border:1px solid #D6D6D6;padding: 5px;">
						<div id="boxColor" style="height:50px;width:50px;">sss</div>
					</div>


					<h2 class="twenty">滑动函数</h2>
					<pre class="brush: xml">
						#panel,#flip
						{
							padding:5px;
							text-align:center;
							background-color:#e5eecc;
							border:solid 1px #c3c3c3;
						}
						#panel
						{
							padding:50px;
							display:none;
						}
					</pre>
					<pre class="brush: javascript">
						//slideToggle:上下滑动
						$("#flip").click(function(){
							$("#panel").slideToggle("slow");
						});
					</pre>
					<p>结果如下:</p>
					<div class="cover" style="height:120px;border:1px solid #D6D6D6;padding: 5px;">
						<div id="flip" style="padding:5px;text-align:center;background-color:#e5eecc;border:solid 1px #c3c3c3;">点我，显示或隐藏面板。</div>
						<div id="panel" style="padding:5px;display:none;height:80px;text-align:center;background-color:#e5eecc;border:solid 1px #c3c3c3;">Hello world!</div>
					</div>

					<h2 class="twenty">阻止冒泡事件</h2>
					<pre class="brush: javascript">
						$("#link").on("click",function(e){
							alert("事件一");
							//e.preventDefault();.//阻止浏览器默认事件
							//e.stopPropagation();//阻止事件冒泡
							return false;//既能阻止浏览器默认事件,也能阻止事件冒泡
						});
						$(body).on("click",function(){
							alert("事件二");
						});
					</pre>

					<h2 class="twenty">end()方法</h2>
					<pre class="brush: javascript">
						var wxhp = "*";
						var wxxp = "x";
						$("#link").on("mouseenter",function(e){
							//end方法:
							$(this).text("wxhp").prevAll().text(wxhp).end().nextAll().text("wxxp");
						});

					</pre>

				</div>
			</section>

			<section id="shell">
				<div class="content-header">
					<h1>linux命令和SHELL</h1>
				</div>


				<div class="features">
					<h2 class="twenty">Linux实用命令</h2>
					<h6>df</h6>
					<pre class="brush: bash">
						# df -h /etc   <==等待你的输入！将 /etc 底下的可用的磁盘容量以易读的容量格式显示
						Filesystem            Size  Used Avail Use% Mounted on
						/dev/hdc2             9.5G  3.7G  5.4G  41% /
					</pre>
					<h6>du</h6>
					<p>Linux du命令也是查看使用空间的，但是与df命令不同的是Linux du命令是对文件和目录磁盘使用的空间的查</p>
					<pre class="brush: bash">
						du -sm /*   c查根目录底下每个目录所占用的容量
						7       /bin
						6       /boot
						3859    /usr     <==系统初期最大
					</pre>
					<h6>fdisk</h6>
					<p>fdisk 是 Linux 的磁盘分区表操作工具</p>
					<pre class="brush: bash">
						[root@www ~]# df /            <==注意：重点在找出磁盘文件名而已
						Filesystem           1K-blocks      Used Available Use% Mounted on
						/dev/hdc2              9920624   3823168   5585388  41% /

						[root@www ~]# fdisk /dev/hdc  <==仔细看，不要加上数字喔！
						The number of cylinders for this disk is set to 5005.
						There is nothing wrong with that, but this is larger than 1024,
						and could in certain setups cause problems with:
						1) software that runs at boot time (e.g., old versions of LILO)
						2) booting and partitioning software from other OSs
						   (e.g., DOS FDISK, OS/2 FDISK)

						Command (m for help):     <==等待你的输入！
					</pre>
					<p>输入 m 后，就会看到底下这些命令介绍</p>
					<pre class="brush: bash">
					Command (m for help): m   <== 输入 m 后，就会看到底下这些命令介绍
					Command action
					   a   toggle a bootable flag
					   b   edit bsd disklabel
					   c   toggle the dos compatibility flag
					   d   delete a partition            <==删除一个partition
					   l   list known partition types
					   m   print this menu
					   n   add a new partition           <==新增一个partition
					   o   create a new empty DOS partition table
					   p   print the partition table     <==在屏幕上显示分割表
					   q   quit without saving changes   <==不储存离开fdisk程序
					   s   create a new empty Sun disklabel
					   t   change a partition's system id
					   u   change display/entry units
					   v   verify the partition table
					   w   write table to disk and exit  <==将刚刚的动作写入分割表
					   x   extra functionality (experts only)
					</pre>
					<p>使用 p 可以列出目前这颗磁盘的分割表信息，这个信息的上半部在显示整体磁盘的状态</p>
					<p>离开 fdisk 时按下 q，那么所有的动作都不会生效！相反的， 按下w就是动作生效的意思。</p>
					<pre class="brush: bash">
						Command (m for help): p  <== 这里可以输出目前磁盘的状态

						Disk /dev/hdc: 41.1 GB, 41174138880 bytes        <==这个磁盘的文件名与容量
						255 heads, 63 sectors/track, 5005 cylinders      <==磁头、扇区与磁柱大小
						Units = cylinders of 16065 * 512 = 8225280 bytes <==每个磁柱的大小

						   Device Boot      Start         End      Blocks   Id  System
						/dev/hdc1   *           1          13      104391   83  Linux
						/dev/hdc2              14        1288    10241437+  83  Linux
						/dev/hdc3            1289        1925     5116702+  83  Linux
						/dev/hdc4            1926        5005    24740100    5  Extended
						/dev/hdc5            1926        2052     1020096   82  Linux swap / Solaris
						# 装置文件名 启动区否 开始磁柱    结束磁柱  1K大小容量 磁盘分区槽内的系统

						Command (m for help): q
					</pre>
					<p>磁盘挂载与卸除</p>
					<pre class="brush: bash">
						# mount /dev/hdc6 /mnt/hdc6  <==创建的 /dev/hdc6 挂载到 /mnt/hdc6 上面
						# umount /dev/hdc6 <==卸载/dev/hdc6
					</pre>
					<p>防火墙的关闭和开启</p>
					<pre class="brush: bash">
						# systemctl stop firewalld.service #关闭防火墙命令

						# systemctl start firewalld.service #开启防火墙

						# systemctl disable firewalld.service # 关闭开机自启动

						# systemctl enable firewalld.service 开启开机启动
					</pre>

					<p>查看进程</p>
					<pre class="brush: bash">
						# ps -ef | grep java
						# ps -aux | grep java
						# kill -9 [PID]
					</pre>

					<p>vi命令</p>
					<pre class="brush: bash">
						G：光标移至最后一行
						nG：光标移至第n行首
						n+：光标下移n行
						n-：光标上移n行
					</pre>

				</div>

				<div class="features">
					<h2 class="twenty">shell脚本</h2>
					<ol>
						<li>脚本运行</li>
						<pre class="brush: bash">
							chmod +x ./test.sh  #使脚本具有执行权限
							./test.sh  #执行脚本  要写成 ./test.sh
						</pre>
						<li>变量循环</li>
						<pre class="brush: bash">
							for file in `ls /etc`  #不推荐
							或
							for file in $(ls /etc)
						</pre>
						<li>拼接字符串</li>
						<h6>双引号里可以出现转义字符</h6>
						<pre class="brush: bash">
							your_name="zhoubin"
							greeting_1="hello, ${your_name} !"
						</pre>
						<pre class="brush: bash">
							hello, zhoubin !
						</pre>

						<h6>单引号拼接出现转义字符</h6>
						<pre class="brush: bash">
							greeting_1='hello, ${your_name} !'
						</pre>
						<pre class="brush: bash">
							hello, ${your_name} !
						</pre>

						<h6>获取字符串长度和截取字符串</h6>
						<pre class="brush: bash">
							echo ${#string}
							echo ${string:1:4}
						</pre>
						<h6>查找子字符串：查找字符 i 或 o 的位置</h6>
						<pre class="brush: bash">
							echo `expr index "$string" io`
						</pre>


						<li>Shell 数组</li>
						<h6>读取数组</h6>
						<pre class="brush: bash">
							echo ${array_name[@]}
						</pre>
						<h6>获取数组的长度:获取数组长度的方法与获取字符串长度的方法相同</h6>
						<pre class="brush: bash">
							# 取得数组元素的个数
							length=${#array_name[@]}
							# 或者
							length=${#array_name[*]}
							# 取得数组单个元素的长度
							lengthn=${#array_name[n]}
						</pre>

						<li>Shell 传递参数</li>
						<h6>$* 与 $@ 区别</h6>
						<h6>只有在双引号中体现出来。假设在脚本运行时写了三个参数 1、2、3，，则 " * " 等价于 "1 2 3"（传递了一个参数），而 "@" 等价于 "1" "2" "3"（传递了三个参数）</h6>
						<pre class="brush: bash">
							#!/bin/bash
							# author:zhoubin
							# url:www.binleir.cn

							echo "-- \$* 演示 ---"
							for i in "$*"; do
							echo $i
							done

							echo "-- \$@ 演示 ---"
							for i in "$@"; do
							echo $i
							done
						</pre>
						<pre class="brush: bash">
							$ chmod +x test.sh
							$ ./test.sh 1 2 3
							-- $* 演示 ---
							1 2 3
							-- $@ 演示 ---
							1
							2
							3
						</pre>
					</ol>

				</div>

			</section>
			
			<section id="goLang">
				<div class="content-header">
					<h1>goLang基础</h1>
				</div>


				<div class="features">
					<ol>
						<li>变量声明</li>
						<h6>不带声明格式的只能在函数体中出现</h6>
						<pre class="brush: bash">
							package main
							import (
								"fmt"
							)

							var s1 = 10

							func main() {
								s2 := 11  //不带声明格式的只能在函数体中出现
								fmt.Println(s1)
							}
						</pre>
						<li>常量声明</li>
						<pre class="brush: bash">
							func main() {
								const LENGTH int = 10
								const a, b, c = 1, false, "str"//多重赋值
								fmt.Println(a, b, c)
							}
						</pre>
						<li>常用函数区别</li>
						<h6>len(),cap()</h6>
						<pre class="brush: bash">
							func main() {
								slice1 := make([]int, 5)
								slice2 := make([]int, 6, 10)
								fmt.Println(slice1, len(slice1), cap(slice1)) //len在slice返回的是个数，而cap则返回的是最大容量
								fmt.Println(slice2, len(slice2), cap(slice2))
							}
						</pre>
						<pre class="brush: bash">
							$ go run temp.go
							[0 0 0 0 0] 5 5
							[0 0 0 0 0 0] 6 10

						</pre>
						<li>iota</li>
						<h6>iota是特殊常量，在关键字const出现时，被重置为0</h6>
						<img src="img/9.png"/>
						<pre class="brush: python">
							Zhoubin-HX@DESKTOP-TT9T6VQ MINGW64 /d/Go/work
							$ go run temp.go
							0 1 2 zhoubin zhoubin 100 100 7 8
						</pre>
						<img src="img/10.png"/>
						<pre class="brush: python">
							$ go run temp.go
							1 8 16 32
						</pre>

					</ol>
					
					
				</div>

			

			</section>
			
		</div>
	</div>
	
	
	<!-- Essential JavaScript Libraries
	==============================================-->

	<script type="text/javascript" src="js/jquery-1.11.0.min.js"></script>
	<script type="text/javascript" src="js/jquery.color.js"></script>
	<script type="text/javascript" src="js/custom.js"></script>
	<script type="text/javascript" src="js/jquery.nav.js"></script>
	<script type="text/javascript" src="syntax-highlighter/scripts/shCore.js"></script>
	<script type="text/javascript" src="syntax-highlighter/scripts/shBrushJava.js"></script>
	<script type="text/javascript" src="syntax-highlighter/scripts/shBrushPython.js"></script>
	<script type="text/javascript" src="syntax-highlighter/scripts/shBrushBash.js"></script>
	<script type="text/javascript" src="syntax-highlighter/scripts/shBrushErlang.js"></script>
	<script type="text/javascript" src="syntax-highlighter/scripts/shBrushXml.js"></script>
	<script type="text/javascript" src="syntax-highlighter/scripts/shBrushCss.js"></script>
	<script type="text/javascript" src="syntax-highlighter/scripts/shBrushJScript.js"></script>

	<script type="text/javascript">
		SyntaxHighlighter.all();
	</script>

	
</body>
</html>