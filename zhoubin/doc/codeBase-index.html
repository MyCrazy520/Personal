<!DOCTYPE html>
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->
<head>
	<meta charset="utf-8">
	<title>ZHOU BIN</title>
	<meta name="description" content="">
	<!-- Mobile Specific Meta -->
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<!-- <link rel="shortcut icon" href="img/favicon.png"> -->
	<link href='http://fonts.googleapis.com/css?family=Lato:300,400,700' rel='stylesheet'>
	<!-- Syntax Highlighter -->
	<link rel="stylesheet" type="text/css" href="syntax-highlighter/styles/shCore.css" media="all">
	<link rel="stylesheet" type="text/css" href="syntax-highlighter/styles/shThemeDefault.css" media="all">
	<!-- Font Awesome CSS-->
	<link rel="stylesheet" href="css/font-awesome.min.css">
	<!-- Normalize/Reset CSS-->
	<link rel="stylesheet" href="css/normalize.min.css">
	<!-- Main CSS-->
	<link rel="stylesheet" href="css/main.css">
	
</head>

<body id="welcome">
	
	<aside class="left-sidebar">
		<div class="logo">
			<a href="../index.html">
				<img src="img/logo.png" alt="">
			</a>
		</div>
		<nav class="left-nav">
			<ul id="nav">
				<li class="current"><a href="#java">JAVA</a></li>
				<li><a href="#python3">PYTHON3</a></li>
				<li><a href="#htmlCSS">HTML+CSS</a></li>
				<li><a href="#less">LESS</a></li>
				<li><a href="#javaScript">JAVASCRIPT</a></li>
				<li><a href="#shell">SHELL</a></li>
				<li><a href="#goLang">GOLANG</a></li>
				
			</ul>
		</nav>
	</aside>
	
	<div id="main-wrapper">
		<div class="main-content">

			<section id="java">
				<div class="content-header">
					<h1>JAVA常用特性</h1>
				</div>

				<div class="welcome">

					<h2 class="twenty">Java8排序和Java7排序</h2>
					<pre class="brush: java">
						private void sortUsingJava8(List&ltString&gt names){
							Collections.sort(names, (s1, s2) -> s1.compareTo(s2));
						}
					</pre>
					<pre class="brush: java">
						private void sortUsingJava7(List&ltString&gt names){
						  Collections.sort(names, new Comparator&ltString&gt() {
							 @Override
							 public int compare(String s1, String s2) {
								return s1.compareTo(s2);
							 }
						  });
					    }
					</pre>
				</div>

				<div class="features">
					<h2 class="twenty">Java 8 日期时间 API</h2>
					<pre class="brush: java">
						// 本地化日期时间 API
						public void testLocalDateTime(){

						  LocalDateTime currentTime = LocalDateTime.now();
						  System.out.println("当前时间: " + currentTime);

						  LocalDate date1 = currentTime.toLocalDate();
						  System.out.println("date1: " + date1);

						  Month month = currentTime.getMonth();
						  int day = currentTime.getDayOfMonth();
						  int seconds = currentTime.getSecond();

						  System.out.println("月: " + month +", 日: " + day +", 秒: " + seconds);

						  LocalDateTime date2 = currentTime.withDayOfMonth(10).withYear(2012);
						  System.out.println("date2: " + date2);

						  // 12 december 2014
						  LocalDate date3 = LocalDate.of(2014, Month.DECEMBER, 12);
						  System.out.println("date3: " + date3);

						  // 22 小时 15 分钟
						  LocalTime date4 = LocalTime.of(22, 15);
						  System.out.println("date4: " + date4);

						  // 解析字符串
						  LocalTime date5 = LocalTime.parse("20:15:30");
						  System.out.println("date5: " + date5);
					   	}


						//输出结果如下:
						当前时间: 2016-09-15T20:55:48.668
						date1: 2016-04-15
						月: APRIL, 日: 15, 秒: 48
						date2: 2016-09-15T20:55:48.668
						date3: 2014-12-12
						date4: 22:15
						date5: 20:15:30


						// 使用时区的日期时间API
						public void testZonedDateTime(){

							ZonedDateTime date1 = ZonedDateTime.parse("2015-12-03T10:15:30+05:30[Asia/Shanghai]");
							System.out.println("date1: " + date1);

							ZoneId id = ZoneId.of("Europe/Paris");
							System.out.println("ZoneId: " + id);

							ZoneId currentZone = ZoneId.systemDefault();
							System.out.println("当期时区: " + currentZone);
						}


						//输出结果如下:
						date1: 2015-12-03T10:15:30+08:00[Asia/Shanghai]
						ZoneId: Europe/Paris
						当期时区: Asia/Shanghai

					</pre>

				</div>

				<div class="features">
					<h2 class="twenty">并行数组</h2>
					<pre class="brush: java">
						// 本地化日期时间 API
						public void testParallelSort(){

						  long[] arrayOfLong = new long [ 20000 ];

							Arrays.parallelSetAll( arrayOfLong,
								index -> ThreadLocalRandom.current().nextInt( 1000000 ) );
							Arrays.stream( arrayOfLong ).limit( 10 ).forEach(
								i -> System.out.print( i + " " ) );
							System.out.println();

							Arrays.parallelSort( arrayOfLong );
							Arrays.stream( arrayOfLong ).limit( 10 ).forEach(
								i -> System.out.print( i + " " ) );
							System.out.println();
						}

						//输出结果如下:
						Unsorted: 591217 891976 443951 424479 766825 351964 242997 642839 119108 552378
						Sorted: 39 220 263 268 325 607 655 678 723 793
					</pre>

				</div>

				<div class="section-content">
					<h2 class="twenty">Java 8 JVM的新特性</h2>
					<ol>
						使用Metaspace（JEP 122）代替持久代（PermGen space）。在JVM参数方面，使用-XX:MetaSpaceSize和-XX:MaxMetaspaceSize代替原来的-XX:PermSize和-XX:MaxPermSize
					</ol>

				</div>

				<div class="section-content">
					<h2 class="twenty">HashMap和CurrentHashMap</h2>
					<ol>
						<li>HashMap没有锁机制，不是线程安全的;而CurrentHashMap在每个分段片上都用锁进行保护，从而让锁的粒度更精细一些，并发性能更好</li>
						<li>ConcurrentHashMap对整个桶数组进行了分段，而HashMap则没有</li>
						<li>Synchronized Map和Hashtable效率低</li>
					</ol>

				</div>
				<div class="section-content">
					<h2 class="twenty">BlockingQuee中ArrayBlockingQueue,LinkedBlockingQueue</h2>
					<ol>
						<li>基于数组的阻塞队列实现，在ArrayBlockingQueue内部，维护了一个定长数组，以便缓存队列中的数据对象，这是一个常用的阻塞队列，除了一个定长数组外，ArrayBlockingQueue内部还保存着两个整形变量，分别标识着队列的头部和尾部在数组中的位置</li>
						<li>基于链表的阻塞队列，同ArrayListBlockingQueue类似，其内部也维持着一个数据缓冲队列（该队列由一个链表构成），当生产者往队列中放入一个数据时，队列会从生产者手中获取数据，并缓存在队列内部，而生产者立即返回；只有当队列缓冲区达到最大值缓存容量时（LinkedBlockingQueue可以通过构造函数指定该值），才会阻塞生产者队列，直到消费者从队列中消费掉一份数据，生产者线程会被唤醒，反之对于消费者这端的处理也基于同样的原理</li>
						<li>如果构造一个LinkedBlockingQueue对象，而没有指定其容量大小，LinkedBlockingQueue会默认一个类似无限大小的容量（Integer.MAX_VALUE），这样的话，如果生产者的速度一旦大于消费者的速度，也许还没有等到队列满阻塞产生，系统内存就有可能已被消耗殆尽了</li>
					</ol>
				</div>
				<div class="section-content">
					<h2 class="twenty">ConcurrentLinkedQueue一个很好用的队列</h2>
					<ol>
						<li>offer是往队列添加元素，poll是从队列取出元素并且删除该元素</li>
						<li>peek:获取但不移除此队列的头；如果此队列为空，则返回 null</li>
						<li>contains:如果此队列包含指定元素，则返回 true</li>
						<li>iterator:返回在此队列元素上以恰当顺序进行迭代的迭代器</li>
						<pre class="brush:java">
							public static void main(String[] args) throws InterruptedException {
								ConcurrentLinkedQueue$lt;String$rt; queue = new ConcurrentLinkedQueue$lt;String$rt;();
								queue.offer("123");
								queue.offer("234");
								Iterator$lt;String$rt; iterator = queue.iterator();
								while (iterator.hasNext()){
									System.out.println(iterator.next());
								}
							}
						</pre>

					</ol>
				</div>

				<div class="section-content">
					<h2 class="twenty">Java中的BIO,NIO,AIO</h2>
					<ol>
						<li>BIO:JDK1.4以前用的是BIO,阻塞IO</li>
						<li>NIO:同步非阻塞方式，目前的主流，采用多路复用技术</li>
						<pre class="brush: java"></pre>
						<li>AIO:JDK1.7才实现真正的异步AIO术</li>
						<pre class="brush: java">
							public class AioServer {
								public AioServer(int port) throws IOException {
									AsynchronousServerSocketChannel listener = AsynchronousServerSocketChannel.open().bind(new InetSocketAddress(port));
									listener.accept(null, new CompletionHandler&lt;AsynchronousSocketChannel, Void&rt;() {
										@Override
										public void completed(AsynchronousSocketChannel ch, Void vi) {
											listener.accept(null,this);//接受下一个连接
											handler(ch);
										}

										@Override
										public void failed(Throwable exc, Void attachment) {
											System.out.println("async io error");
										}
									});
								}

								//业务逻辑
								public void handler(AsynchronousSocketChannel ch){
									ByteBuffer byteBuffer = ByteBuffer.allocate(32);
									try {
										ch.read(byteBuffer).get();
									} catch (InterruptedException e) {
										e.printStackTrace();
									} catch (ExecutionException e) {
										e.printStackTrace();
									}
									byteBuffer.flip();
									System.out.println("service accept:"+byteBuffer.get());
								}

								public static void main(String[] args) throws InterruptedException, IOException {
									int port = 7080;
									AioServer server= new AioServer(port);
									System.out.println("watcher listner:"+port);
									Thread.sleep(60000);
								}
							}
						</pre>
						<pre class="brush: java">
							public class AioClient {
								private AsynchronousSocketChannel client = null;
								public AioClient(String host, int port) throws IOException, ExecutionException, InterruptedException {
									client = AsynchronousSocketChannel.open();
									Future<?> future = client.connect(new InetSocketAddress(host,port));
									System.out.println("get:"+future.get());
								}

								public void write(byte b){
									ByteBuffer byteBuffer = ByteBuffer.allocate(32);
									byteBuffer.put(b);
									byteBuffer.flip();
									client.write(byteBuffer);
								}

								public static void main(String[] args ) throws InterruptedException, ExecutionException, IOException {
									AioClient client = new AioClient("127.0.0.1",7080);
									client.write((byte)34);
								}
							}
						</pre>
						<li>FileChanne</li>
						<pre class="brush:java">
							public  void readFile(String path) throws IOException {
								ByteBuffer byteBuffer = ByteBuffer.allocate(1024);//定义缓冲区
								FileChannel inFC = new FileInputStream(path).getChannel();
								byteBuffer.clear();
								int len = inFC.read(byteBuffer);
								String content = new String(byteBuffer.array(),0,len);
								System.out.println(content);

								String fileWritePath = "C://Users/77363/iwillcome.txt";
								this.writeFile(fileWritePath,content);

								inFC.close();
							}

							public void writeFile(String pathFile,String Content) throws IOException {
								FileChannel outFC = new FileOutputStream(pathFile,true).getChannel();

								ByteBuffer byteBuffer = ByteBuffer.wrap(Content.getBytes());
								outFC.write(byteBuffer);
								outFC.close();
							}
						</pre>
					</ol>
				</div>

			</section>

			<section id="python3">
				<div class="content-header">
					<h1>PYTHON3</h1>
				</div>


				<div class="features">
					<h2 class="twenty">List（列表）</h2>
					<pre class="brush: python">
						#!/usr/bin/python3

						list = [ 'abcd', 786 , 2.23, 'runoob', 70.2 ]
						tinylist = [123, 'runoob']

						print (list)            # 输出完整列表
						print (list[0])         # 输出列表第一个元素
						print (list[1:3])       # 从第二个开始输出到第三个元素
						print (list[2:])        # 输出从第三个元素开始的所有元素
						print (tinylist * 2)    # 输出两次列表
						print (list + tinylist) # 连接列表

						#以上实例输出结果：
						['abcd', 786, 2.23, 'runoob', 70.2]
						abcd
						[786, 2.23]
						[2.23, 'runoob', 70.2]
						[123, 'runoob', 123, 'runoob']
						['abcd', 786, 2.23, 'runoob', 70.2, 123, 'runoob']
					</pre>
					<h6>与Python字符串不一样的是，列表中的元素是可以改变的:</h6>
					<pre class="brush: python">
						>>>a = [1, 2, 3, 4, 5, 6]
						>>> a[0] = 9
						>>> a[2:5] = [13, 14, 15]
						>>> a
						[9, 2, 13, 14, 15, 6]
						>>> a[2:5] = []   # 将对应的元素值设置为 []
						>>> a
						[9, 2, 6]
					</pre>
					<h6>List内置了有很多方法:</h6>
					<pre class="brush: python">
						append
						pop
						remove:删除指定值,无序
						del
					</pre>

				</div>

				<div class="features">
					<h2 class="twenty">Tuple（元组）</h2>
					<pre class="brush: python">
						#!/usr/bin/python3

						tuple = ( 'abcd', 786 , 2.23, 'runoob', 70.2  )
						tinytuple = (123, 'runoob')

						print (tuple)             # 输出完整元组
						print (tuple[0])          # 输出元组的第一个元素
						print (tuple[1:3])        # 输出从第二个元素开始到第三个元素
						print (tuple[2:])         # 输出从第三个元素开始的所有元素
						print (tinytuple * 2)     # 输出两次元组
						print (tuple + tinytuple) # 连接元组

						#以上实例输出结果：
						('abcd', 786, 2.23, 'runoob', 70.2)
						abcd
						(786, 2.23)
						(2.23, 'runoob', 70.2)
						(123, 'runoob', 123, 'runoob')
						('abcd', 786, 2.23, 'runoob', 70.2, 123, 'runoob')
					</pre>

				</div>

				<div class="section-content">
					<h2 class="title">Set（集合）:</h2>
					<pre class="brush: python">
						#!/usr/bin/python3

						student = {'Tom', 'Jim', 'Mary', 'Tom', 'Jack', 'Rose'}
						print(student)   # 输出集合，重复的元素被自动去掉

						# 成员测试
						if 'Rose' in student :
							print('Rose 在集合中')
						else :
							print('Rose 不在集合中')


						# set可以进行集合运算
						a = set('abracadabra')
						b = set('alacazam')

						print(a)

						print(a - b)     # a 和 b 的差集

						print(a | b)     # a 和 b 的并集

						print(a & b)     # a 和 b 的交集

						print(a ^ b)     # a 和 b 中不同时存在的元素

						#以上实例输出结果：
						{'Mary', 'Jim', 'Rose', 'Jack', 'Tom'}
						Rose 在集合中
						{'b', 'a', 'c', 'r', 'd'}
						{'b', 'd', 'r'}
						{'l', 'r', 'a', 'c', 'z', 'm', 'b', 'd'}
						{'a', 'c'}
						{'l', 'r', 'z', 'm', 'b', 'd'}
					</pre>
				</div>

				<div class="section-content">
					<h2 class="title">Dictionary（字典）:</h2>
					<pre class="brush: python">
						#!/usr/bin/python3

						dict = {}
						dict['one'] = "1 - 菜鸟教程"
						dict[2]     = "2 - 菜鸟工具"




						print (dict['one'])       # 输出键为 'one' 的值
						print (dict[2])           # 输出键为 2 的值
						print (tinydict)          # 输出完整的字典
						print (tinydict.keys())   # 输出所有键
						print (tinydict.values()) # 输出所有值



						#以上实例输出结果：
						1 - 菜鸟教程
						2 - 菜鸟工具
						{'name': 'runoob', 'code': 1, 'site': 'www.runoob.com'}
						dict_keys(['name', 'code', 'site'])
						dict_values(['runoob', 1, 'www.runoob.com'])
					</pre>
					<pre class="brush: python">
						#直接从键值对序列中构建字典
						>>>dict([('Runoob', 1), ('Google', 2), ('Taobao', 3)])
						{'Taobao': 3, 'Runoob': 1, 'Google': 2}

						>>> {x: x**2 for x in (2, 4, 6)}
						{2: 4, 4: 16, 6: 36}

						>>> dict(Runoob=1, Google=2, Taobao=3)
						{'Runoob': 1, 'Google': 2, 'Taobao': 3}
					</pre>
				</div>


			</section>

			<section id="htmlCSS">
				<div class="content-header">
					<h1>HTML+CSS</h1>
				</div>


				<div class="features">
					<h2 class="twenty">CSS样式名之间空格,无空格和大于号的区别</h2>
					<p>CSS 多类选择器:IE7 之前的版本中，不同平台的 Internet Explorer 都不能正确地处理多类选择器</p>
					<pre class="brush: xml">
						<!--.layout.float两者之间无空格-->
						.layout.float { color: red; }
						<div class="layout float">被选择的元素</div>
					</pre>
					<p>CSS 后代选择器</p>
					<pre class="brush: xml">
						<!--.layout .float中间用空格隔开，表示后代选择器，选择的是.layout内的.float (两个元素之间的层次间隔可以是无限的)-->
						.layout .float{
						  color: orange;
						}
						<div class="layout">
							<div class="float">被选择的元素</div>
						</div>
					</pre>
					<p>CSS 子元素选择器</p>
					<pre class="brush: xml">
						<!--.layout > .float中间是大于号，表示元素的子元素-->
						.layout > .float{
						  color: blue;
						}
						<div class="layout">
							<div class="float">被选择的元素</div>
							<div>
								<div class="float">没有被选择的元素</div>
							</div>
						</div>
					</pre>

				</div>


			</section>

			<section id="less">
				
				<div class="content-header">
					<h1>LESS</h1>
				</div>

				<div class="features">
					<h2 class="twenty">混合</h2>
					<p>LESS代码</p>
					<pre class="brush: css">
						.rounded-corners (@radius: 5px) {
						  border-radius: @radius;
						  -webkit-border-radius: @radius;
						  -moz-border-radius: @radius;
						}

						#header {
						  .rounded-corners;
						}
						#footer {
						  .rounded-corners(10px);
						}
					</pre>
					<p>生成的CSS</p>
					<pre class="brush: css">
						#header {
						  border-radius: 5px;
						  -webkit-border-radius: 5px;
						  -moz-border-radius: 5px;
						}
						#footer {
						  border-radius: 10px;
						  -webkit-border-radius: 10px;
						  -moz-border-radius: 10px;
						}
					</pre>
				
				</div>

				<div class="features">
					<h2 class="twenty">嵌套规则</h2>
					<p>LESS代码</p>
					<pre class="brush: css">
						#header {
						  color: black;

						  .navigation {
							font-size: 12px;
						  }
						  .logo {
							width: 300px;
							&:hover { text-decoration: none }
						  }
						}
					</pre>
					<p>生成的CSS</p>
					<pre class="brush: css">
						#header { color: black; }
						#header .navigation {
						  font-size: 12px;
						}
						#header .logo { 
						  width: 300px; 
						}
						#header .logo:hover {
						  text-decoration: none;
						}
					</pre>
				
				</div>
				
				<div class="features">
					<h2 class="twenty">函数 & 运算</h2>
					<p>LESS代码</p>
					<pre class="brush: css">
						@the-border: 1px;
						@base-color: #111;
						@red:        #842210;

						#header {
						  color: @base-color * 3;
						  border-left: @the-border;
						  border-right: @the-border * 2;
						}
						#footer { 
						  color: @base-color + #003300;
						  border-color: desaturate(@red, 10%);
						}
					</pre>
					<p>生成的CSS</p>
					<pre class="brush: css">
						#header {
						  color: #333;
						  border-left: 1px;
						  border-right: 2px;
						}
						#footer { 
						  color: #114411;
						  border-color: #7d2717;
						}
					</pre>
				
				</div>
												
				<div class="features">
					<h2 class="twenty">作用域</h2>
					<p>LESS代码</p>
					<pre class="brush: css">
						@var: red;
						#page {
						  @var: white;
						  #header {
							color: @var; // white
						  }
						}

						#footer {
						  color: @var; // red  
						}
					</pre>				
				</div>

			</section>

			<section id="shell">
				<div class="content-header">
					<h1>linux命令和SHELL</h1>
				</div>


				<div class="features">
					<h2 class="twenty">Linux实用命令</h2>
					<h6>df</h6>
					<pre class="brush: bash">
						# df -h /etc   <==等待你的输入！将 /etc 底下的可用的磁盘容量以易读的容量格式显示
						Filesystem            Size  Used Avail Use% Mounted on
						/dev/hdc2             9.5G  3.7G  5.4G  41% /
					</pre>
					<h6>du</h6>
					<p>Linux du命令也是查看使用空间的，但是与df命令不同的是Linux du命令是对文件和目录磁盘使用的空间的查</p>
					<pre class="brush: bash">
						du -sm /*   c查根目录底下每个目录所占用的容量
						7       /bin
						6       /boot
						3859    /usr     <==系统初期最大
					</pre>
					<h6>fdisk</h6>
					<p>fdisk 是 Linux 的磁盘分区表操作工具</p>
					<pre class="brush: bash">
						[root@www ~]# df /            <==注意：重点在找出磁盘文件名而已
						Filesystem           1K-blocks      Used Available Use% Mounted on
						/dev/hdc2              9920624   3823168   5585388  41% /

						[root@www ~]# fdisk /dev/hdc  <==仔细看，不要加上数字喔！
						The number of cylinders for this disk is set to 5005.
						There is nothing wrong with that, but this is larger than 1024,
						and could in certain setups cause problems with:
						1) software that runs at boot time (e.g., old versions of LILO)
						2) booting and partitioning software from other OSs
						   (e.g., DOS FDISK, OS/2 FDISK)

						Command (m for help):     <==等待你的输入！
					</pre>
					<p>输入 m 后，就会看到底下这些命令介绍</p>
					<pre class="brush: bash">
					Command (m for help): m   <== 输入 m 后，就会看到底下这些命令介绍
					Command action
					   a   toggle a bootable flag
					   b   edit bsd disklabel
					   c   toggle the dos compatibility flag
					   d   delete a partition            <==删除一个partition
					   l   list known partition types
					   m   print this menu
					   n   add a new partition           <==新增一个partition
					   o   create a new empty DOS partition table
					   p   print the partition table     <==在屏幕上显示分割表
					   q   quit without saving changes   <==不储存离开fdisk程序
					   s   create a new empty Sun disklabel
					   t   change a partition's system id
					   u   change display/entry units
					   v   verify the partition table
					   w   write table to disk and exit  <==将刚刚的动作写入分割表
					   x   extra functionality (experts only)
					</pre>
					<p>使用 p 可以列出目前这颗磁盘的分割表信息，这个信息的上半部在显示整体磁盘的状态</p>
					<p>离开 fdisk 时按下 q，那么所有的动作都不会生效！相反的， 按下w就是动作生效的意思。</p>
					<pre class="brush: bash">
						Command (m for help): p  <== 这里可以输出目前磁盘的状态

						Disk /dev/hdc: 41.1 GB, 41174138880 bytes        <==这个磁盘的文件名与容量
						255 heads, 63 sectors/track, 5005 cylinders      <==磁头、扇区与磁柱大小
						Units = cylinders of 16065 * 512 = 8225280 bytes <==每个磁柱的大小

						   Device Boot      Start         End      Blocks   Id  System
						/dev/hdc1   *           1          13      104391   83  Linux
						/dev/hdc2              14        1288    10241437+  83  Linux
						/dev/hdc3            1289        1925     5116702+  83  Linux
						/dev/hdc4            1926        5005    24740100    5  Extended
						/dev/hdc5            1926        2052     1020096   82  Linux swap / Solaris
						# 装置文件名 启动区否 开始磁柱    结束磁柱  1K大小容量 磁盘分区槽内的系统

						Command (m for help): q
					</pre>
					<p>磁盘挂载与卸除</p>
					<pre class="brush: bash">
						# mount /dev/hdc6 /mnt/hdc6  <==创建的 /dev/hdc6 挂载到 /mnt/hdc6 上面
						# umount /dev/hdc6 <==卸载/dev/hdc6
					</pre>
				</div>

				<div class="features">
					<h2 class="twenty">shell脚本</h2>
					<ol>
						<li>脚本运行</li>
						<pre class="brush: bash">
							chmod +x ./test.sh  #使脚本具有执行权限
							./test.sh  #执行脚本  要写成 ./test.sh
						</pre>
						<li>变量循环</li>
						<pre class="brush: bash">
							for file in `ls /etc`  #不推荐
							或
							for file in $(ls /etc)
						</pre>
						<li>拼接字符串</li>
						<h6>双引号里可以出现转义字符</h6>
						<pre class="brush: bash">
							your_name="zhoubin"
							greeting_1="hello, ${your_name} !"
						</pre>
						<pre class="brush: bash">
							hello, zhoubin !
						</pre>

						<h6>单引号拼接出现转义字符</h6>
						<pre class="brush: bash">
							greeting_1='hello, ${your_name} !'
						</pre>
						<pre class="brush: bash">
							hello, ${your_name} !
						</pre>

						<h6>获取字符串长度和截取字符串</h6>
						<pre class="brush: bash">
							echo ${#string}
							echo ${string:1:4}
						</pre>
						<h6>查找子字符串：查找字符 i 或 o 的位置</h6>
						<pre class="brush: bash">
							echo `expr index "$string" io`
						</pre>


						<li>Shell 数组</li>
						<h6>读取数组</h6>
						<pre class="brush: bash">
							echo ${array_name[@]}
						</pre>
						<h6>获取数组的长度:获取数组长度的方法与获取字符串长度的方法相同</h6>
						<pre class="brush: bash">
							# 取得数组元素的个数
							length=${#array_name[@]}
							# 或者
							length=${#array_name[*]}
							# 取得数组单个元素的长度
							lengthn=${#array_name[n]}
						</pre>

						<li>Shell 传递参数</li>
						<h6>$* 与 $@ 区别</h6>
						<h6>只有在双引号中体现出来。假设在脚本运行时写了三个参数 1、2、3，，则 " * " 等价于 "1 2 3"（传递了一个参数），而 "@" 等价于 "1" "2" "3"（传递了三个参数）</h6>
						<pre class="brush: bash">
							#!/bin/bash
							# author:zhoubin
							# url:www.binleir.cn

							echo "-- \$* 演示 ---"
							for i in "$*"; do
							echo $i
							done

							echo "-- \$@ 演示 ---"
							for i in "$@"; do
							echo $i
							done
						</pre>
						<pre class="brush: bash">
							$ chmod +x test.sh
							$ ./test.sh 1 2 3
							-- $* 演示 ---
							1 2 3
							-- $@ 演示 ---
							1
							2
							3
						</pre>
					</ol>

				</div>

			</section>
			
			<section id="goLang">
				<div class="content-header">
					<h1>goLang基础</h1>
				</div>


				<div class="features">
					<ol>
						<li>变量声明</li>
						<h6>不带声明格式的只能在函数体中出现</h6>
						<pre class="brush: bash">
							package main
							import (
								"fmt"
							)

							var s1 = 10

							func main() {
								s2 := 11  //不带声明格式的只能在函数体中出现
								fmt.Println(s1)
							}
						</pre>
						<li>常量声明</li>
						<pre class="brush: bash">
							func main() {
								const LENGTH int = 10
								const a, b, c = 1, false, "str"//多重赋值
								fmt.Println(a, b, c)
							}
						</pre>
						<li>常用函数区别</li>
						<h6>len(),cap()</h6>
						<pre class="brush: bash">
							func main() {
								slice1 := make([]int, 5)
								slice2 := make([]int, 6, 10)
								fmt.Println(slice1, len(slice1), cap(slice1)) //len在slice返回的是个数，而cap则返回的是最大容量
								fmt.Println(slice2, len(slice2), cap(slice2))
							}
						</pre>
						<pre class="brush: bash">
							$ go run temp.go
							[0 0 0 0 0] 5 5
							[0 0 0 0 0 0] 6 10

						</pre>
						<li>iota</li>
						<h6>iota是特殊常量，在关键字const出现时，被重置为0</h6>
						<img src="img/9.png"/>
						<pre class="brush: python">
							Zhoubin-HX@DESKTOP-TT9T6VQ MINGW64 /d/Go/work
							$ go run temp.go
							0 1 2 zhoubin zhoubin 100 100 7 8
						</pre>
						<img src="img/10.png"/>
						<pre class="brush: python">
							$ go run temp.go
							1 8 16 32
						</pre>

					</ol>
					
					
				</div>

			

			</section>
			
		</div>
	</div>
	
	
	<!-- Essential JavaScript Libraries
	==============================================-->
	<script type="text/javascript" src="js/jquery-1.11.0.min.js"></script>
	<script type="text/javascript" src="js/jquery.nav.js"></script>
	<script type="text/javascript" src="syntax-highlighter/scripts/shCore.js"></script>
	<script type="text/javascript" src="syntax-highlighter/scripts/shBrushJava.js"></script>
	<script type="text/javascript" src="syntax-highlighter/scripts/shBrushPython.js"></script>
	<script type="text/javascript" src="syntax-highlighter/scripts/shBrushBash.js"></script>
	<script type="text/javascript" src="syntax-highlighter/scripts/shBrushErlang.js"></script>
	<script type="text/javascript" src="syntax-highlighter/scripts/shBrushXml.js"></script>
	<script type="text/javascript" src="syntax-highlighter/scripts/shBrushCss.js"></script>
	<script type="text/javascript">
		SyntaxHighlighter.all()
	</script>
	<script type="text/javascript" src="js/custom.js"></script>
	
</body>
</html>